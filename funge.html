<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<script language="javascript">
			function load() {
				document.getElementById("go").addEventListener("click", go);
				document.getElementById("stop").addEventListener("click", stop);
				document.getElementById("copydown").addEventListener("click", copydown);
				document.getElementById("copyup").addEventListener("click", copyup);
				document.getElementById("toggle_pause").addEventListener("click", toggle_pause);
				document.getElementById("step").addEventListener("click", step);
				document.getElementById("history").addEventListener("change", load_history);
				window.addEventListener('keydown', keydown, false);
				saved_history = JSON.parse(window.localStorage.getItem("history") || "[]");
				update_history();
				if (saved_history.length > 0) {
					load_history();
				}
				copydown();
				out_area = document.getElementById("out");
				go();
				let p = new Promise(r => setTimeout(r, 10000));
				async function f(i) {
					await p;
					console.log("test" + i + Date.now() / 1000);
				}
				f(1);
				f(2);
			}
			let paused_wake = null;
			function toggle_pause(e) {
				if (paused_wake === null) {
					pause();
				} else {
					unpause();
				}
			}
			let pause_count = 0;
			function pause() {
				let paused_event = new Promise(function (r) { paused_wake = r; null; });
				paused_event.id = pause_count++;
				threads.forEach(t => t.paused_event = paused_event);
				document.getElementById("toggle_pause").innerText = "Wake all!";
			}
			function unpause() {
				paused_wake("unpause");
				paused_wake = null;
				document.getElementById("toggle_pause").innerText = "Pause all!";
			}
			function step(e) {
				let old_wake = paused_wake;
				pause();
				if (old_wake !== null) {
					old_wake("step");
				}
			}
			let editing = {"state": false};
			function keydown(e) {
				let key = e.key;
				if (key == "Backspace" || key == "Delete") {
					key = " ";
				}
				if (key == "Escape") {
					editing.state = false;
					editing.element.classList.remove("editing");
					return;
				}
				if (key.length != 1 && !key.startsWith("Arrow")) {
					console.log("Key " + key + " has weird length; keyCode is " + e.keyCode);
					return;
				}
				if (editing.state) {
					editing.element.classList.remove("editing");
					if (key.length == 1) {
						field[editing.row][editing.col] = key;
						editing.element.innerText = key;
						editing.col += 1;
					} else if (key == "ArrowUp") {
						editing.row -= 1;
					} else if (key == "ArrowDown") {
						editing.row += 1;
					} else if (key == "ArrowRight") {
						editing.col += 1;
					} else if (key == "ArrowLeft") {
						editing.col -= 1;
					}
					if (editing.col < 0) editing.col = 0;
					else if (editing.col >= width) editing.col = width - 1;
					if (editing.row < 0) editing.row = 0;
					else if (editing.row >= height) editing.row = height - 1;
					editing.element = document.getElementById("table").children[editing.row].children[editing.col];
					if (editing.element !== null) {
						editing.element.classList.add("editing");
					} else {
						editing = {"state": false};
					}
					e.preventDefault();
				}
			}
			function begin_edit(col, row, td) {
				if (editing.state) {
					editing.element.classList.remove("editing");
				} else {
					editing.state = true;
				}
				editing.element = td;
				editing.element.classList.add("editing");
				editing.col = col;
				editing.row = row;
			}
			function go() {
				stop();
				out_area.innerText = "";
				thread({"col": -1, "row": 0, "cold": 1, "rowd": 0, running: true, mode: "normal", stack: [], paused_event: null});
			}
			let saved_history;
			function append_save() {
				let current = {
					ts: new Date().toLocaleString(),
					data: document.getElementById("area").value,
					height: field.length,
					width: field[0].length,
				};
				if (saved_history.length == 0 || current.data != saved_history[0].data) {
					saved_history.unshift(current);
				}
				while(saved_history.length > 200) {
					saved_history.pop();
				}
				window.localStorage.setItem("history", JSON.stringify(saved_history));
				update_history();
			}
			function load_history() {
				let history_elt = document.getElementById("history");
				let history_data = saved_history[parseInt(history_elt.options[history_elt.selectedIndex].value)];
				document.getElementById("area").value = history_data.data;
				document.getElementById("area").cols = history_data.width;
				document.getElementById("area").rows = history_data.height;
				document.getElementById("width").value = history_data.width;
				document.getElementById("height").value = history_data.height;
			}
			function update_history() {
				let history_elt = document.getElementById("history");
				while(history_elt.children.length > 0)
					history_elt.removeChild(history_elt.children[0]);
				for(let i=0; i<saved_history.length; i++) {
					let e = document.createElement("option");
					e.value = i;
					e.innerText = saved_history[i].ts;
					history_elt.appendChild(e);
				}
			}
			function stop() {
				while(threads.length>0) {
					threads.pop().running = false;
				}
			}
			let out_area;
			function pop(state) {
				if (state.stack.length > 0) {
					return state.stack.pop();
				} else {
					error(state, "Stack underflow");
					return 0;
				}
			}
			function check(state, row, col) {
				console.log("" + row + " " + col);
				if (row < 0 || row >= height) error(state, "Row " + row + " is out of bounds");
				else if (col < 0 || col >= height) error(state, "Col " + col + " is out of bounds");
				else return true;
			}
			let instructions = {
				"+": function (state) { state.stack.push(pop(state) + pop(state)); },
				"-": function (state) { state.stack.push(-pop(state) + pop(state)); },
				"*": function (state) { state.stack.push(pop(state) * pop(state)); },
				"/": function (state) { state.stack.push(Math.floor(pop(state) / pop(state))); },
				"%": function (state) { state.stack.push(pop(state) % pop(state)); },
				"!": function (state) { state.stack.push(pop(state) == 0 ? 1 : 0); },
				"`": function (state) { state.stack.push(pop(state) < pop(state) ? 1 : 0); },
				"<": function (state) { state.cold = -1; state.rowd =  0; },
				">": function (state) { state.cold =  1; state.rowd =  0; },
				"^": function (state) { state.cold =  0; state.rowd = -1; },
				"v": function (state) { state.cold =  0; state.rowd =  1; },
				// "?" random direction, TODO.
				"_": function (state) { state.rowd =  0; state.cold = pop(state) == 0 ? 1 : -1; },
				"|": function (state) { state.cold =  0; state.rowd = pop(state) == 0 ? 1 : -1; },
				'"': function (state) { state.mode = "string"; },
				":": function (state) { state.stack.push(state.stack[state.stack.length-1]); },
				"\\": function (state) { let a = pop(state); var b = pop(state); state.stack.push(a, b); },
				"$": function (state) { pop(state); },
				".": function (state) { out(pop(state) + " "); },
				",": function (state) { out(String.fromCharCode(pop(state))); },
				"#": function (state) { state.col += state.cold; state.row += state.rowd; },
				"g": function (state) { let row = pop(state); var col = pop(state); if (check(state, row, col)) { state.stack.push(field[row][col].charCodeAt(0)); } },
				"p": function (state) { let row = pop(state); var col = pop(state); if (check(state, row, col)) { var val = String.fromCharCode(pop(state)); field[row][col] = val; document.getElementById("table").children[row].children[col].innerText = val; document.getElementById("table").children[row].children[col].title = "" + val.charCodeAt(0); } },
				"t": function (state) { state_copy = JSON.parse(JSON.stringify(state)); state_copy.paused_event = state.paused_event; state_copy.cold *= -1; state_copy.rowd *= -1; thread(state_copy); },
				// "&" input number TODO
				// "~" input characte TODO
				"@": function (state) { oute("Normal termination!"); state.running = false; },
				" ": function (state) { },
			};
			for(let i=0; i<10; i++) {
				const j = i; // Prevent any capture shenanigans.
				instructions["" + i] = function (state) { state.stack.push(j); };
			}
			function out(s) {
				out_area.appendChild(document.createTextNode(s));
			}
			function oute(s) {
				let span = document.createElement("p");
				span.className = "error";
				span.innerText = s;
				out_area.appendChild(span);
			}
			function outnl() {
				out_area.appendChild(document.createElement("br"));
			}
			function error(state, message) {
				state.running = false;
				oute("ERROR: " + message);
				oute("State was: " + JSON.stringify(state));
			}
			let field = [];
			let threads = [];
			async function sleep(ms) {
				await new Promise(r => setTimeout(r, ms));
			}
			async function thread(state) {
				threads.push(state);
				state.count = 0;
				state.slice_loops = document.getElementById("slice_loops").value;
				state.slice_sleep = document.getElementById("slice_sleep").value;
				state.max_loops = document.getElementById("max_loops").value;
				let highlighted = document.getElementById("table").children[state.row + state.rowd].children[state.col + state.cold];
				highlighted.classList.add("active");
				while(state.running) {
					state.col += state.cold;
					state.row += state.rowd;
					if (state.row == height) state.row = 0;
					else if (state.row == -1) state.row = state.height - 1;
					if (state.col == width) state.col = 0;
					else if (state.col == -1) state.col = state.width - 1;
					if (state.count > state.max_loops) {
						error(state, "Exceeded max instructions!");
						state.running = false;
						break;
					}
					let slept = false;
					if (state.paused_event !== null) {
						highlighted.classList.remove("active");
						highlighted = document.getElementById("table").children[state.row].children[state.col];
						highlighted.classList.add("active");
						let paused_event = state.paused_event;
						console.log("Awaiting unpause " + paused_event.id + " " + JSON.stringify(state));
						let result = await paused_event;
						if (state.paused_event === paused_event)
							state.paused_event = null;
						console.log("Unpaused " + paused_event.id + " " + JSON.stringify(result) + " " + JSON.stringify(state));
						slept = true;
					}
					if (!slept && state.count % state.slice_loops == 0) {
						highlighted.classList.remove("active");
						highlighted = document.getElementById("table").children[state.row].children[state.col];
						highlighted.classList.add("active");
						// Give the browser back some time.
						await sleep(state.slice_sleep);
					}
					let symbol = field[state.row][state.col];
					if (state.mode == "normal") {
						let instruction = instructions[symbol];
						if (instruction == null) {
							error(state, "Invalid instruction: " + symbol);
						} else {
							try {
								instruction(state);
							} catch (err) {
								error(state, "Exception caught: " + err.message);
							}
						}
					} else if (state.mode == "string") {
						if (symbol == '"') {
							state.mode = "normal";
						} else {
							state.stack.push(symbol.charCodeAt(0));
						}
					}
					state.count += 1;
				}
				idx = threads.findIndex(x => x === state);
				threads.splice(idx, 1);
				highlighted.classList.remove("active");
			}
			function copydown() {
				let lines = document.getElementById("area").value.split("\n");
				let table = document.getElementById("table");
				let height = document.getElementById("height").value;
				let width = document.getElementById("width").value;
				while(table.children.length > height) {
					table.removeChild(table.children[table.children.length-1]);
					field.pop();
				}
				while(table.children.length < height) {
					table.appendChild(document.createElement("tr"));
					field.push([]);
				}
				for(let i=0; i<height; i++) {
					let line;
					if (i >= lines.length)
						line = "";
					else 
						line = lines[i];
					let row = table.children[i];
					while(row.children.length > width) {
						row.removeChild(row.children[row.children.length-1]);
						field[i].pop();
					}
					while(row.children.length < width) {
						const td = document.createElement("td");
						const rown = i;
						const coln = row.children.length;
						td.addEventListener("click", function() { begin_edit(coln, rown, td); });
						row.appendChild(td);
						field[i].push(" ");
					}
					for(let j=0; j<width; j++) {
						let val;
						if (j >= line.length)
							val = " ";
						else
							val = line[j]
						row.children[j].innerText = val == ' ' ? "\u00a0" : val;
						row.children[j].title = "" + val.charCodeAt(0);
						field[i][j] = val;
					}
				}
				append_save();
			}
			function copyup() {
				let table = document.getElementById("table");
				let lines = [];
				let linesbuf = [];
				document.getElementById("height").value = field.length;
				document.getElementById("width").value = field[0].length;
				for(let i=0; i<field.length; i++) {
					let line = "";
					let linebuf = "";
					let row = field[i];
					for(let j=0; j<row.length; j++) {
						linebuf += field[i][j];
						if (field[i][j] != " ") {
							line += linebuf;
							linebuf = "";
						}
					}
					if (line == "") {
						linesbuf.push(line);
					} else {
						while (linesbuf.length > 0) {
							lines.push(linesbuf.shift());
						}
						lines.push(line);
					}
				}
				document.getElementById("area").value = lines.join("\n");
				append_save();
			}
		</script>
<style>
table { border: black solid 1px; padding: 0px; }
td { background: lightgrey; width: 1em; padding: 0px; text-align: center; }
#out { font-family: monospace; border: black solid 1px; }
.error { background-color: red; margin: 0px; }
.active { background-color: lightpink; }
.editing { background-color: lightgreen; }
</style>
				<title>Befunge</title>
	</head>
	<body onload="load();">
		<h1>Befunge-ish interpreter</h1>
		<p>© 2024. This work is openly licensed via <i><a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a></i></p>
		<p>You can click the grid to edit cells. Press escape to release input
		grab. Saves (to browser local storage) are made each time you copy
		up/down. Max 200. Probably copy/paste elsewhere if it's important.</p>
		<p>Bugs are pretty rife. It's a WIP.</p>
		Edit code:<br/>
		<textarea id="area" rows="25" cols="80">#vt                                    v  Originally made for virtualharby's LOVE game jam
                                       #  https://itch.io/jam/virtualharby
  Challenge:         +---------------------------------------------------------+
* Edit only          |                                                         |
  whitespace.        |                                                         |
* Edit only within   |          ####       ####                                |
  square.            |         #    #     #    #                               |
* Output exactly:    |        #      #####      #                              |
  You win            |       #        ###        #                             |
  Normal termination!|       &gt;#v&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;v                             |
  Normal termination!|       ^ &gt;0"niw uoY":!v!:&lt; v                             |
#####################|       ^ @    p+990"@"_,#^ v                             |
                     |       ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;                             |
 &gt;994++21p331p041pv  |        #                 #                              |
v             p151&lt;  |         #               #                               |
&gt;21g:31gg\"#"\31gp::v|          #             #                                |
pv-" "_v#-"\"_v#-"/"&lt;|           #           #                                 |
 &gt;#v_v  v-10$$&lt;      |            #         #                                  |
 v  &lt;  &gt; $1&gt;:41g*\51v|             #       #                                   |
        &gt;  ^v15p14*g&lt;|              #     #                                    |
   &gt;  041g-4 1p051g-v|               #   #                                     |
 v" "&lt;     p&lt;     15&lt;|                # #                                      |
 &gt;21g:31g:51g+31p\41v|                 #                                       |
^              p12+g&lt;|                                                         |
                     +---------------------------------------------------------+
</textarea>
		<br/>
		W=<input type="number" id="width" value="80"/>
		H=<input type="number" id="height" value="25"/>
		<br/>
		Load: <select id="history"></select>
		<br/>
		<button id="copydown">Copy To Memory (Down v)</button>
		<button id="copyup">Copy From Memory (Up ^)</button>
		<hr/>
		Sleep <input type="number" id="slice_sleep" value="10"/> ms every <input type="number" id="slice_loops" value="1"/> instructions, exit after <input type="number" id="max_loops" value="1000000"/> instructions
		<br/>
		<button id="go">Go!</button>
		<button id="stop">Terminate!</button>
		<button id="toggle_pause">Pause all!</button>
		<button id="step">Step all!</button>
		<table id="table">
		</table>
		<hr/>
		<div id="out"></div>
	</body>
</html>
