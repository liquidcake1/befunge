<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<script language="javascript">
			function load() {
				document.getElementById("go").addEventListener("click", go);
				document.getElementById("stop").addEventListener("click", stop);
				document.getElementById("copydown").addEventListener("click", copydown);
				document.getElementById("copyup").addEventListener("click", copyup);
				document.getElementById("toggle_pause").addEventListener("click", toggle_pause);
				document.getElementById("step").addEventListener("click", step);
				document.getElementById("history").addEventListener("change", load_history);
				document.getElementById("speed").addEventListener("input", set_speed);
				window.addEventListener('keydown', keydown, false);
				saved_history = JSON.parse(window.localStorage.getItem("history") || "[]");
				update_history();
				copydown();
				set_speed();
				go();
			}

			let editing = {"state": false};
			function keydown(e) {
				let key = e.key;
				if (key == "Backspace" || key == "Delete") {
					key = " ";
				}
				if (key == "Escape") {
					editing.state = false;
					editing.element.classList.remove("editing");
					return;
				}
				if (key.length != 1 && !key.startsWith("Arrow")) {
					console.log("Key " + key + " has weird length; keyCode is " + e.keyCode);
					return;
				}
				if (editing.state) {
					editing.element.classList.remove("editing");
					if (key.length == 1) {
						set_cell(editing.element, editing.col, editing.row, key.charCodeAt(0));
						editing.col += 1;
					} else if (key == "ArrowUp") {
						editing.row -= 1;
					} else if (key == "ArrowDown") {
						editing.row += 1;
					} else if (key == "ArrowRight") {
						editing.col += 1;
					} else if (key == "ArrowLeft") {
						editing.col -= 1;
					}
					if (editing.col < 0) editing.col = 0;
					else if (editing.col >= width) editing.col = width - 1;
					if (editing.row < 0) editing.row = 0;
					else if (editing.row >= height) editing.row = height - 1;
					editing.element = document.getElementById("table").children[editing.row].children[editing.col];
					if (editing.element !== null) {
						editing.element.classList.add("editing");
					} else {
						editing = {"state": false};
					}
					e.preventDefault();
				}
			}
			function begin_edit(col, row, td) {
				if (editing.state) {
					editing.element.classList.remove("editing");
				} else {
					editing.state = true;
				}
				editing.element = td;
				editing.element.classList.add("editing");
				editing.col = col;
				editing.row = row;
			}

			let saved_history;
			function append_save() {
				let current = {
					ts: new Date().toLocaleString(),
					data: document.getElementById("area").value,
					height: field.length,
					width: field[0].length,
				};
				if (saved_history.length == 0 || current.data != saved_history[0].data) {
					saved_history.unshift(current);
				}
				while(saved_history.length > 200) {
					saved_history.pop();
				}
				window.localStorage.setItem("history", JSON.stringify(saved_history));
				update_history();
			}
			function load_history() {
				let history_elt = document.getElementById("history");
				let history_data = saved_history[parseInt(history_elt.options[history_elt.selectedIndex].value)];
				document.getElementById("area").value = history_data.data;
				document.getElementById("area").cols = history_data.width;
				document.getElementById("area").rows = history_data.height;
				document.getElementById("width").value = history_data.width;
				document.getElementById("height").value = history_data.height;
			}
			function update_history() {
				let history_elt = document.getElementById("history");
				while(history_elt.children.length > 0)
					history_elt.removeChild(history_elt.children[0]);
				for(let i=0; i<saved_history.length; i++) {
					let e = document.createElement("option");
					e.value = i;
					e.innerText = saved_history[i].ts;
					history_elt.appendChild(e);
				}
			}

			let run_state = {
				paused_wake: null,
				paused_event: null,
				slice_loops: 1,
				slice_sleep: 20,
				running: false,
				threads: [],
			};
			function set_speed(e) {
				let raw_speed = document.getElementById("speed").value;
				if (raw_speed > 0) {
					run_state.slice_sleep = 1;
					run_state.slice_loops = Math.floor(1.1 ** raw_speed);
				} else {
					run_state.slice_sleep = Math.floor(1.1 ** -raw_speed);
					run_state.slice_loops = 1;
				}
				document.getElementById("slice_sleep").innerText = run_state.slice_sleep;
				document.getElementById("slice_loops").innerText = run_state.slice_loops;
			}
			function toggle_pause(e) {
				if (run_state.paused_wake === null) {
					pause();
				} else {
					unpause();
				}
			}
			function pause() {
				run_state.paused_event = new Promise(function (r) { run_state.paused_wake = r; });
				document.getElementById("toggle_pause").innerText = "Wake all!";
				run_state.threads.forEach(function (thread) {
					thread.info_elt.children[0].children[0].children[0].children[0].removeAttribute("disabled");
				});
			}
			function unpause() {
				let old_wake = run_state.paused_wake;
				run_state.paused_wake = null;
				document.getElementById("toggle_pause").innerText = "Pause all!";
				run_state.threads.forEach(function (thread) {
					thread.info_elt.children[0].children[0].children[0].children[0].setAttribute("disabled", "disabled");
				});
				if (old_wake !== null) {
					old_wake({});
				}
			}
			function step(e) {
				let old_wake = run_state.paused_wake;
				pause();
				if (old_wake !== null) {
					old_wake({count: 1});
				}
			}
			function step_thread(thread) {
				let old_wake = run_state.paused_wake;
				pause();
				if (old_wake !== null) {
					old_wake({threads: [thread], count: 1});
				}
			}
			function new_thread(col, row, cold, rowd) {
				let thread_info = document.createElement("p");
				document.getElementById("threads").appendChild(thread_info);
				return {"col": col, "row": row, "cold": cold, "rowd": rowd, running: true, mode: "normal", stack: [], info_elt: thread_info};
			}
			function split_thread(old_thread) {
				return new_thread(old_thread.col, old_thread.row, -old_thread.cold, -old_thread.rowd, JSON.parse(JSON.stringify(old_thread.stack)));
			}
			function go() {
				stop();
				document.getElementById("out").innerText = "";
				let thread = new_thread(-1, 0, 1, 0, []);
				run_state.threads.push(thread);
				main_loop();
			}
			function stop() {
				run_state.threads.forEach(function (thread) { thread.running = false; });
				unpause();
			}

			function pop(state) {
				if (state.stack.length > 0) {
					return state.stack.pop();
				} else {
					error(state, "Stack underflow");
					return 0;
				}
			}
			function check(state, row, col) {
				if (row < 0 || row >= height) error(state, "Row " + row + " is out of bounds");
				else if (col < 0 || col >= height) error(state, "Col " + col + " is out of bounds");
				else return true;
			}
			function set_field(state, col, row, val) {
				if (check(state, col, row)) {
					set_cell(document.getElementById("table").children[row].children[col], col, row, val);
				} else {
					console.log("out of bounds access " + state + " " + col + " " + row + " " + val);
				}
			}
			function set_cell(cell, col, row, val) {
				let val_str = String.fromCharCode(val);
				field[row][col] = val;
				document.getElementById("table").children[row].children[col].innerText = val_str == " " ? "\u00a0" : val_str;
				let title = "(" + col + "," + row + ")=" + val + " (" + val_str + ")";
				if (instructions_raw[val_str] !== undefined)
					title += ": " + instructions_raw[val_str].desc;
				document.getElementById("table").children[row].children[col].title = title;
			}
			function get_field(state, col, row, val) {
				if (check(state, col, row)) {
					return field[row][col];
				}
			}
			let instructions_raw = {
				"+": {
					impl: function (state) { state.stack.push(pop(state) + pop(state)); },
					desc: "b a → b + a",
				},
				"-": {
					impl: function (state) { state.stack.push(-pop(state) + pop(state)); },
					desc: "b a → b - a",
				},
				"*": {
					impl: function (state) { state.stack.push(pop(state) * pop(state)); },
					desc: "b a → b * a",
				},
				"/": {
					impl: function (state) { let a = pop(state); let b = pop(state); state.stack.push(Math.floor(b / a)); },
					desc: "b a → b // a",
				},
				"%": {
					impl: function (state) { let a = pop(state); let b = pop(state); state.stack.push(b % a); },
					desc: "b a → b % a",
				},
				"!": {
					impl: function (state) { state.stack.push(pop(state) == 0 ? 1 : 0); },
					desc: "a → a == 0 ? 1 : 0",
				},
				"`": {
					impl: function (state) { state.stack.push(pop(state) < pop(state) ? 1 : 0); },
					desc: "b a → b > a ? 1 : 0",
				},
				"<": {
					impl: function (state) { state.cold = -1; state.rowd =  0; },
					desc: "() → (); go left",
				},
				">": {
					impl: function (state) { state.cold =  1; state.rowd =  0; },
					desc: "() → (); go right",
				},
				"^": {
					impl: function (state) { state.cold =  0; state.rowd = -1; },
					desc: "() → (); go up",
				},
				"v": {
					impl: function (state) { state.cold =  0; state.rowd =  1; },
					desc: "() → (); go down",
				},
				"?": {
					impl: function (state) { let x = Math.floor(Math.random() * 4); state.cold = ((x % 2) * 2 - 1) * Math.floor(x / 2); state.rowd = ((x % 2) * 2 - 1) * ( 1 - Math.floor(x / 2)); },
					desc: "() → (); go random cardinal",
				},
				"_": {
					impl: function (state) { state.rowd =  0; state.cold = pop(state) == 0 ? 1 : -1; },
					desc: "a → (); a == 0 ? go right : go left",
				},
				"|": {
					impl: function (state) { state.cold =  0; state.rowd = pop(state) == 0 ? 1 : -1; },
					desc: "a → (); a == 0 ? go down : go up",
				},
				'"': {
					impl: function (state) { state.mode = "string"; },
					desc: "; toggle string mode",
				},
				":": {
					impl: function (state) { state.stack.push(state.stack[state.stack.length-1]); },
					desc: "a → a a",
				},
				"\\": {
					impl: function (state) { let a = pop(state); var b = pop(state); state.stack.push(a, b); },
					desc: "b a → a b",
				},
				"$": {
					impl: function (state) { pop(state); },
					desc: "a → ()",
				},
				".": {
					impl: function (state) { out(pop(state) + " "); },
					desc: "a → (); output a",
				},
				",": {
					impl: function (state) { out(String.fromCharCode(pop(state))); },
					desc: "a → (); output chr(a)",
				},
				"#": {
					impl: function (state) { state.col += state.cold; state.row += state.rowd; },
					desc: "; jump one cell",
				},
				"g": {
					impl: function (state) { let row = pop(state); var col = pop(state); state.stack.push(get_field(state, col, row)); },
					desc: "col row → field[row][col]",
				},
				"p": {
					impl: function (state) { let row = pop(state); var col = pop(state); var val = pop(state); set_field(state, col, row, val); },
					desc: "val row col → (); field[row][col] = val",
				},
				"t": {
					impl: function (state) { run_state.threads.push(split_thread(state)); },
					desc: "; create new thread in reverse direction",
				},
				// "&".charCodeAt(0) input number TODO
				// "~".charCodeAt(0) input characte TODO
				"@": {
					impl: function (state) { oute("Normal termination!"); state.running = false; },
					desc: "; stop current thread",
				},
				" ": {
					impl: function (state) { },
					desc: "; no-op",
				},
			};
			for(let i=0; i<10; i++) {
				const j = i; // Prevent any capture shenanigans.
				instructions_raw["" + i] = {
					impl: function (state) { state.stack.push(j); },
					desc: "() → " + i,
				};
			}
			// Fast access instructions array.
			let instructions = {};
			for(let [s, val] of Object.entries(instructions_raw)) {
				instructions[s.charCodeAt(0)] = val.impl;
			}

			function out(s) {
				document.getElementById("out").appendChild(document.createTextNode(s));
			}
			function oute(s) {
				let span = document.createElement("p");
				span.className = "error";
				span.innerText = s;
				document.getElementById("out").appendChild(span);
			}
			function outnl() {
				document.getElementById("out").appendChild(document.createElement("br"));
			}
			function error(state, message) {
				state.running = false;
				oute("ERROR: " + message);
				oute("State was: " + JSON.stringify(state));
			}

			let field = [];
			async function sleep(ms) {
				await new Promise(r => setTimeout(r, ms));
			}
			async function main_loop() {
				let ticks = 0;
				run_state.running = true;
				while(run_state.threads.length > 0) {
					let slice_loops = run_state.slice_loops;
					let limit_threads = null;
					if (run_state.paused_event) {
						let paused_event = run_state.paused_event;
						run_state.paused_event = null;
						unpause_data = await paused_event;
						if (unpause_data.count !== undefined)
							slice_loops = unpause_data.count;
						if (unpause_data.threads !== undefined)
							limit_threads = unpause_data.threads;
					}
					let count = 0;
					let to_unhighlight = new Set();
					for(let i=0; i<run_state.threads.length; i++) {
						if (run_state.threads[i].highlighted)
							to_unhighlight.add(run_state.threads[i].highlighted);
					}
					while(count < slice_loops && run_state.threads.length > 0) {
						// This will _not_ iterate over newly-added threads.
						let to_iter = limit_threads !== null ? limit_threads : run_state.threads;
						to_iter.forEach(thread => tick(thread));
						count += run_state.threads.length;
						let dead_threads = run_state.threads.filter(t => !t.running);
						if (dead_threads.length > 0) {
							dead_threads.forEach(dead_thread => document.getElementById("threads").removeChild(dead_thread.info_elt));
						}
						run_state.threads = run_state.threads.filter(t => t.running);
					}
					ticks += count;
					let to_highlight = new Set();
					for(let i=0; i<run_state.threads.length; i++) {
						let state = run_state.threads[i];
						let cell = document.getElementById("table").children[state.row].children[state.col];
						to_unhighlight.delete(cell);
						to_highlight.add(cell);
						state.highlighted = cell;
					}
					to_unhighlight.forEach(a => a.classList.remove("active"));
					if (ticks > document.getElementById("max_loops").value)
						error(run_state, "Ran out of ticks!");
					if (!run_state.running)
						break;
					to_highlight.forEach(a => a.classList.add("active"));
					run_state.threads.forEach(function (thread) {
						if (thread.info_elt.children.length == 0) {
							let button = document.createElement("button");
							button.setAttribute("disabled", "disabled");
							const this_thread = thread;
							button.addEventListener("click", function () { step_thread(this_thread); });
							button.innerText = "Step";
							let thb = document.createElement("th");
							thb.appendChild(button);
							let table = document.createElement("table");
							let tr = document.createElement("tr");
							let th = document.createElement("th");
							tr.appendChild(thb);
							tr.appendChild(th);
							table.appendChild(tr);
							thread.info_elt.appendChild(table);
						}
						let tr = thread.info_elt.children[0].children[0];
						tr.children[1].innerText = "(" + ("" + thread.col).padStart(3, "\u00a0") + "," + ("" + thread.row).padStart(3, "\u00a0") + ")";
						while(tr.children.length > thread.stack.length + 2) {
							tr.removeChild(tr.children[tr.children.length - 1]);
						}
						while(tr.children.length < thread.stack.length + 2) {
							tr.appendChild(document.createElement("td"));
						}
						thread.stack.forEach(function (val, idx) {
							tr.children[thread.stack.length - idx + 1].innerText = val;
						});
					});
					await sleep(run_state.slice_sleep);
				}
				console.log("exited main_loop with ticks " + ticks);
			}
			function tick(state) {
				state.count += 1;
				state.col += state.cold;
				state.row += state.rowd;
				if (state.row == field.length) state.row = 0;
				else if (state.row == -1) state.row = field.length - 1;
				if (state.col == field[0].length) state.col = 0;
				else if (state.col == -1) state.col = field[0].length - 1;
				let symbol = field[state.row][state.col];
				if (state.mode == "normal") {
					let instruction = instructions[symbol];
					if (instruction == null) {
						error(state, "Invalid instruction: " + symbol);
					} else {
						try {
							instruction(state);
						} catch (err) {
							error(state, "Exception caught: " + err.message);
						}
					}
				} else if (state.mode == "string") {
					if (symbol == '"'.charCodeAt(0)) {
						state.mode = "normal";
					} else {
						state.stack.push(symbol);
					}
				}
			}

			function copydown() {
				let lines = document.getElementById("area").value.split("\n");
				let table = document.getElementById("table");
				let height = document.getElementById("height").value;
				let width = document.getElementById("width").value;
				while(table.children.length > height) {
					table.removeChild(table.children[table.children.length-1]);
					field.pop();
				}
				while(table.children.length < height) {
					table.appendChild(document.createElement("tr"));
					field.push([]);
				}
				for(let i=0; i<height; i++) {
					let line;
					if (i >= lines.length)
						line = "";
					else 
						line = lines[i];
					let row = table.children[i];
					while(row.children.length > width) {
						row.removeChild(row.children[row.children.length-1]);
						field[i].pop();
					}
					while(row.children.length < width) {
						const td = document.createElement("td");
						const rown = i;
						const coln = row.children.length;
						td.addEventListener("click", function() { begin_edit(coln, rown, td); });
						row.appendChild(td);
						field[i].push(32);
					}
					for(let j=0; j<width; j++) {
						let val;
						if (j >= line.length)
							val = " ";
						else
							val = line[j];
						set_cell(row.children[j], j, i, val.charCodeAt(0));
					}
				}
				append_save();
			}
			function copyup() {
				let table = document.getElementById("table");
				let lines = [];
				let linesbuf = [];
				document.getElementById("height").value = field.length;
				document.getElementById("width").value = field[0].length;
				for(let i=0; i<field.length; i++) {
					let line = "";
					let linebuf = "";
					let row = field[i];
					for(let j=0; j<row.length; j++) {
						linebuf += String.fromCharCode(field[i][j]);
						if (field[i][j] != " ") {
							line += linebuf;
							linebuf = "";
						}
					}
					if (line == "") {
						linesbuf.push(line);
					} else {
						while (linesbuf.length > 0) {
							lines.push(linesbuf.shift());
						}
						lines.push(line);
					}
				}
				document.getElementById("area").value = lines.join("\n");
				append_save();
			}
		</script>
<style>
table { border: black solid 1px; padding: 0px; }
th { font-family: monospace; font-weight: normal; }
td { font-family: monospace; background: lightgrey; width: 1em; padding: 0px; text-align: center; }
#out { font-family: monospace; border: black solid 1px; }
.error { background-color: red; margin: 0px; }
.active { background-color: lightpink; }
.editing { background-color: lightgreen; }
#threads { border: black solid 1px; padding: 0px; }
#threads > p { margin: 0px; }
</style>
				<title>Befunge</title>
	</head>
	<body onload="load();">
		<h1>Befunge-ish interpreter</h1>
		<p>© 2024. This work is openly licensed via <i><a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a></i></p>
		<ul>
			<li>You can click the grid to edit cells.</li>
			<li>Press escape to release input grab.</li>
			<li>Hover a cell for co-ordinates and interpretation.</li>
			<li>Saves (to browser local storage) are made each time you copy up/down. Max 200. Probably copy/paste elsewhere if it's important.</li>
			<li>The default should always be reloaded as the newest save if you re-enter the URL. Else it's the earliest history entry. Else delete cookies/use private mode/something.</li>
		</ul>
		<p>Implements (or tries to implement) <a href="https://en.wikipedia.org/wiki/Befunge">Befunge</a> with minor bits from <a href="https://esolangs.org/wiki/Funge-98">Funge-98</a>.</p>
		<p>Bugs are pretty rife. It's a WIP. ChangeLog:</p>
		<ul>
			<li>2024-01-29: Reworked a lot of inner mechanics, added tooltip, added slider to change speed.</li>
			<li>2024-01-28: Working puzzle with many bugs.</li>
			<li>2024-01-27: Mostly working interpreter.</li>
		</ul>
		Edit code:<br/>
		<textarea id="area" rows="25" cols="80">#vt                                    v  Made for LCOLONQ and
                                       #  https://itch.io/jam/virtualharby
  Challenge:         +---------------------------------------------------------+
* Edit only          |                 #                                       |
  whitespace.        |                 #                                       |
* Edit only within   |          ####   #   ####                                |
  square.            |         #    #  #  #    #                               |
* Output exactly:    |        #      #####      #                              |
  You win            |       #        ###        #                             |
  Normal termination!|       &gt;#v&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;v                             |
  Normal termination!|       ^ &gt;0"niw uoY":!v!:&lt; v                             |
#####################|       ^ @    p+990"@"_,#^ v                             |
                     |       ^&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;                             |
 &gt;994++21p331p041pv  |        #                 #                              |
v             p151&lt;  |         #               #                               |
&gt;21g:31gg\"#"\31gp::v|          #             #                                |
pv-" "_v#-"\"_v#-"/"&lt;|           #           #                                 |
 &gt;#v_v  v-10$$&lt;      |            #         #                                  |
 v  &lt;  &gt; $1&gt;:41g*\51v|             #       #                                   |
        &gt;  ^v15p14*g&lt;|              #     #                                    |
   &gt;  041g-4 1p051g-v|               #   #                                     |
 v" "&lt;     p&lt;     15&lt;|                # #                                      |
 &gt;21g:31g:51g+31p\41v|                 #                                       |
^              p12+g&lt;|                                                         |
                     +---------------------------------------------------------+
</textarea>
		<br/>
		W=<input type="number" id="width" value="80"/>
		H=<input type="number" id="height" value="25"/>
		<br/>
		Load: <select id="history"></select>
		<br/>
		<button id="copydown">Copy To Memory (Down v)</button>
		<button id="copyup">Copy From Memory (Up ^)</button>
		<hr/>
		<input type="range" min="-100" max="100" value="0" id="speed"/>
		Sleep <span id="slice_sleep">?</span>ms every <span id="slice_loops">?</span> instructions, exit after <input type="number" id="max_loops" value="1000000"/> instructions
		<br/>
		<button id="go">Go!</button>
		<button id="stop">Terminate!</button>
		<button id="toggle_pause">Pause all!</button>
		<button id="step">Step all!</button>
		<div id="threads"><p>Threads</p></div>
		<table id="table">
		</table>
		<hr/>
		<div id="out"></div>
	</body>
</html>
